<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.33">
    <script>
      const userMode = localStorage.getItem('vuepress-reco-color-scheme');
      const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

      if (userMode === 'dark' || (typeof userMode !== 'string' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true);
      }
    </script>
    <title>sicko</title><meta name="description" content="努力整点薯条">
    <link rel="preload" href="/assets/js/runtime~app.6ffafc36.js" as="script"><link rel="preload" href="/assets/css/styles.a224c88d.css" as="style"><link rel="preload" href="/assets/js/3769.cb625991.js" as="script"><link rel="preload" href="/assets/js/app.f55d247c.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.a224c88d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><div class="common-wrapper no-sidebar show-page-headers"><header class="navbar-container"><div class="toggle-sidebar-button" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span class="site-brand"><a href="/" class=""><img class="logo" src="/avtar.png" alt="sicko"><span class="site-name can-hide">sicko</span></a></span><div class="navbar-links-wrapper" style=""><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Home"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Home<!--]--></span></a><!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories/notes/1/" class="nav-link" aria-label="Categories"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Categories<!--]--></span></a><!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Recommend"><a class="icon-container left title" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Recommend<!--]--></span></a><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Recommend"><a class="icon-container left title" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Recommend<!--]--></span></a><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/docs/monthly/about" class="nav-link" aria-label="月刊"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->月刊<!--]--></span></a><!--[--><!--]--></a></li><li class="dropdown-item"><a href="/docs/way2msg/msg" class="nav-link" aria-label="获取信息的方式"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->获取信息的方式<!--]--></span></a><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><a class="icon-container left btn-toggle-dark-mode" href="javascript:void(0)"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" style="color:inherit;width:20px;height:20px;font-size:20px;"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3h.393a7.5 7.5 0 0 0 7.92 12.446A9 9 0 1 1 12 2.992z"></path><path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0-2 2a2 2 0 0 0-2-2a2 2 0 0 0 2-2"></path><path d="M19 11h2m-1-1v2"></path></g></svg><!----></a></div></header><div class="sidebar-mask"></div><aside class="series-container"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Home"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Home<!--]--></span></a><!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories/notes/1/" class="nav-link" aria-label="Categories"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Categories<!--]--></span></a><!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Recommend"><a class="icon-container left title" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Recommend<!--]--></span></a><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Recommend"><a class="icon-container left title" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Recommend<!--]--></span></a><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/docs/monthly/about" class="nav-link" aria-label="月刊"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->月刊<!--]--></span></a><!--[--><!--]--></a></li><li class="dropdown-item"><a href="/docs/way2msg/msg" class="nav-link" aria-label="获取信息的方式"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->获取信息的方式<!--]--></span></a><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--></aside><!--[--><main class="page-container show-page-headers"><!----><div class="page-info"><a class="icon-container left" href="javascript:void(0)"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" style="color:inherit;width:18px;height:18px;font-size:18px;"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="7" r="4"></circle><path d="M6 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2"></path></g></svg><span style="color:inherit;font-size:14px;"><!--[-->sicko<!--]--></span></a><!----><!----><!----><!----></div><div class="theme-reco-default-content"><!--[--><h2 id="tree" tabindex="-1"><a class="header-anchor" href="#tree" aria-hidden="true">#</a> Tree</h2><p>The goal of this chapter is to:</p><ol><li>Understand the difference between different tree traversal methods;</li><li>Be able to solve preorder, inorder and postorder traversal <code>recursively</code>;</li><li>Be able to solve preorder, inorder and postorder traversal <code>iteratively</code>;</li><li>Be able to do <code>level traversal</code> using <code>BFS</code>.</li></ol><p>we will focus on the traversal methods used in a binary tree. Understanding these traversal methods will definitely help you have a better understanding of the tree structure and have a solid foundation for the further study.</p><h2 id="binary-tree-preorder-traversal" tabindex="-1"><a class="header-anchor" href="#binary-tree-preorder-traversal" aria-hidden="true">#</a> Binary Tree Preorder Traversal</h2><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="asd"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,null,2,3]
Output: [1,2,3]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,null,2,3]
Output: [1,2,3]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = []
Output: []
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1]
Output: [1]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2]
Output: [1,2]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="tree3"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,null,2]
Output: [1,2]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution-Using Recursive</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
      vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>
       <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
        
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p><strong>Solution-Using Iterative</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>class Solution<span class="token punctuation">{</span>
  public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>
	stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> st<span class="token punctuation">;</span>
	st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// remove and print current node from stack </span>
		TreeNode<span class="token operator">*</span> curr <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// preorder: root-&gt;left-&gt;right</span>
		<span class="token comment">// Trick - add Right child before the Left Child so that left child will be removed first</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> 
			st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span>
			st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="binary-tree-inorder-traversal" tabindex="-1"><a class="header-anchor" href="#binary-tree-inorder-traversal" aria-hidden="true">#</a> Binary Tree Inorder Traversal</h2><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="binary-tree-postorder-traversal" tabindex="-1"><a class="header-anchor" href="#binary-tree-postorder-traversal" aria-hidden="true">#</a> Binary Tree Postorder Traversal</h2><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="binary-tree-level-order-traversal" tabindex="-1"><a class="header-anchor" href="#binary-tree-level-order-traversal" aria-hidden="true">#</a> Binary Tree Level Order Traversal</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1]
Output: [[1]]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution-Using Queue</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> 
            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ans<span class="token punctuation">;</span>
        
        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tmp<span class="token punctuation">;</span>
            
            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                TreeNode<span class="token operator">*</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                
                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                
                <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                
                n<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><h2 id="find-max-depth" tabindex="-1"><a class="header-anchor" href="#find-max-depth" aria-hidden="true">#</a> Find Max Depth</h2><p><strong>TOP-down</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1. return specific value for null node
2. update the answer if needed                      // answer &lt;-- params
3. left_ans = top_down(root.left, left_params)      // left_params &lt;-- root.val, params
4. right_ans = top_down(root.right, right_params)   // right_params &lt;-- root.val, params
5. return the answer if needed                      // answer &lt;-- left_ans, right_ans
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> answer<span class="token punctuation">;</span> <span class="token comment">// don&#39;t forget to initialize answer before call maximum_depth</span>
<span class="token keyword">void</span> <span class="token function">maximum_depth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        answer <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">maximum_depth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">maximum_depth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>Bottom-up</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1. return specific value for null node
2. left_ans = bottom_up(root.left)      // call function recursively for left child
3. right_ans = bottom_up(root.right)    // call function recursively for right child
4. return answers                       // answer &lt;-- left_ans, right_ans, root.val
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">maximum_depth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                                 <span class="token comment">// return 0 for null node</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> left_depth <span class="token operator">=</span> <span class="token function">maximum_depth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> right_depth <span class="token operator">=</span> <span class="token function">maximum_depth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>left_depth<span class="token punctuation">,</span> right_depth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// return depth of the subtree rooted at root</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h2><p><strong>When you meet a tree problem, ask yourself two questions: Can you determine some parameters to help the node know its answer? Can you use these parameters and the value of the node itself to determine what should be the parameters passed to its children? If the answers are both yes, try to solve this problem using a &quot;<code>top-down</code>&quot; recursive solution.</strong></p><p><strong>Or, you can think of the problem in this way: for a node in a tree, if you know the answer of its children, can you calculate the answer of that node? If the answer is yes, solving the problem recursively using a <code>bottom up</code> approach might be a good idea.</strong></p><p><strong>In the following sections, we provide several classic problems for you to help you understand tree structure and recursion better.</strong></p><h2 id="symmetric-tree" tabindex="-1"><a class="header-anchor" href="#symmetric-tree" aria-hidden="true">#</a> Symmetric Tree</h2><p><strong>&quot;Simple&quot; Problems</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="s2"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,2,3,4,4,3]
Output: true
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="s3"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,2,null,3,null,3]
Output: false
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution-Recuisive</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    bool <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scan left and right</span>
    <span class="token punctuation">}</span>
    bool <span class="token function">isMirror</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root1<span class="token punctuation">,</span>TreeNode <span class="token operator">*</span>root2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root1<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> root2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        <span class="token comment">// </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">&amp;&amp;</span> root1<span class="token operator">-&gt;</span>val <span class="token operator">==</span> root2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>
            <span class="token comment">// specially from the left to the right &amp; right to the left</span>
            <span class="token keyword">return</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root1<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>root2<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root1<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>root2<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><strong>Solution-Iterative</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    bool <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>
        bool symmetric <span class="token operator">=</span> true<span class="token punctuation">;</span>
        TreeNode <span class="token operator">*</span>temp1<span class="token punctuation">,</span> <span class="token operator">*</span>temp2<span class="token punctuation">;</span>
        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">;</span>
        q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Transverse level From left to right</span>
        q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Tranverse Level From Right to Left</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>q2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> symmetric<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            temp1<span class="token operator">=</span> q1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            temp2 <span class="token operator">=</span> q2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            q1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            q2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp1 <span class="token operator">&amp;&amp;</span> temp2<span class="token punctuation">)</span>
                symmetric <span class="token operator">=</span> temp1<span class="token operator">-&gt;</span>val <span class="token operator">==</span> temp2<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                symmetric <span class="token operator">=</span> temp1 <span class="token operator">==</span> temp2<span class="token punctuation">;</span>
                
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp1<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>temp1<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp1<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp1<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>temp1<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp1<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp2<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>temp2<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp2<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>temp2<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>temp2<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp2<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> q2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            
        <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> <span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> q2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> symmetric<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="path-sum" tabindex="-1"><a class="header-anchor" href="#path-sum" aria-hidden="true">#</a> Path Sum</h2><p><strong>Similar to &quot;Symmetric Tree&quot;</strong></p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="asd" style="zoom:80%;"><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="asdasd"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,3], targetSum = 5
Output: false
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2], targetSum = 0
Output: false
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution - Recursion</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    bool <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        sum<span class="token operator">=</span>sum<span class="token operator">-</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token operator">==</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-&gt;</span>right<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
           <span class="token keyword">return</span> sum<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>       
        <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>sum<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="construct-binary-tree-from-inorder-and-postorder-traversal" tabindex="-1"><a class="header-anchor" href="#construct-binary-tree-from-inorder-and-postorder-traversal" aria-hidden="true">#</a> Construct Binary Tree from Inorder and Postorder Traversal</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="sadasd"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: inorder = [-1], postorder = [-1]
Output: [-1]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution-Recursion</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> n <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    TreeNode<span class="token operator">*</span> <span class="token function">helper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> is<span class="token punctuation">,</span> <span class="token keyword">int</span> ie<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> ps<span class="token punctuation">,</span> <span class="token keyword">int</span> pe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ie<span class="token operator">&lt;</span>is <span class="token operator">||</span> pe<span class="token operator">&lt;</span>ps<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>pe<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">int</span> indexOfHead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val <span class="token operator">!=</span> i<span class="token punctuation">[</span>indexOfHead<span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token operator">++</span>indexOfHead<span class="token punctuation">;</span>
        
        root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> is<span class="token punctuation">,</span> indexOfHead<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> indexOfHead<span class="token operator">+</span>ps<span class="token operator">-</span>is<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> indexOfHead<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> ie<span class="token punctuation">,</span> p<span class="token punctuation">,</span> indexOfHead<span class="token operator">+</span>ps<span class="token operator">-</span>is<span class="token punctuation">,</span> pe<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="construct-binary-tree-from-preorder-and-inorder-traversal" tabindex="-1"><a class="header-anchor" href="#construct-binary-tree-from-preorder-and-inorder-traversal" aria-hidden="true">#</a> Construct Binary Tree from Preorder and Inorder Traversal</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="asdzxcsc"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: preorder = [-1], inorder = [-1]
Output: [-1]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution - Recursion</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Preorder Traversal = [root,left-subtree,right-subtree]
Inorder Traversal = [left-subtree,root,right-subtree]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>we only need to find the root index in <code>Inorder</code>,and left side of the root is left-subtree, the right side is right-subtree.</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> curIdx<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inBeginIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> inEndIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>curIdx <span class="token operator">&gt;=</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> inBeginIdx <span class="token operator">&gt;</span> inEndIdx<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
		TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// find the index of current node in preorder</span>
		<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> inBeginIdx<span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> inEndIdx<span class="token punctuation">,</span> preorder<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> inIdx <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// calculate the number of nodes in left subtree so that we can know where the right leaf begins</span>
		<span class="token keyword">int</span> numOfLeft <span class="token operator">=</span> inIdx <span class="token operator">-</span> inBeginIdx<span class="token punctuation">;</span>
		
		<span class="token comment">// assume that curIdx + 1 would be the left node</span>
		node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> curIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inBeginIdx<span class="token punctuation">,</span> inIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> curIdx <span class="token operator">+</span> numOfLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEndIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p><strong>Solution - Using map</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
	<span class="token comment">// consider that we need to iterate all nodes in the left subtree before building the right one,</span>
	<span class="token comment">// so we can use a simple index to iterate the elements in preorder</span>
    <span class="token keyword">int</span> preIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> inorderMap<span class="token punctuation">;</span>
    
    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
			inorderMap<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">buildTreeWithMap</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    TreeNode<span class="token operator">*</span> <span class="token function">buildTreeWithMap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>     <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&gt;</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
		TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preIdx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> inIdx <span class="token operator">=</span> inorderMap<span class="token punctuation">[</span>node<span class="token operator">-&gt;</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>
		node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">buildTreeWithMap</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> start<span class="token punctuation">,</span> inIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">buildTreeWithMap</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> inIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="populating-next-right-pointers-in-each-node" tabindex="-1"><a class="header-anchor" href="#populating-next-right-pointers-in-each-node" aria-hidden="true">#</a> Populating Next Right Pointers in Each Node</h2><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="asdazc"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>Solution</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/</span>

class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    Node<span class="token operator">*</span> <span class="token function">connect</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Node<span class="token operator">*</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h2 id="lowest-common-ancestor-of-a-binary-tree" tabindex="-1"><a class="header-anchor" href="#lowest-common-ancestor-of-a-binary-tree" aria-hidden="true">#</a> Lowest Common Ancestor of a Binary Tree</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener noreferrer">definition of LCA on Wikipedia<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!----></span></a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="asczxcas"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="azxkcnsaolfd"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2], p = 1, q = 2
Output: 1
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution-Recursive</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>

    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> nullptr<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token operator">==</span>p<span class="token operator">-&gt;</span>val <span class="token operator">||</span> root<span class="token operator">-&gt;</span>val<span class="token operator">==</span>q<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
         TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
         TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span>left and right<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
         <span class="token keyword">return</span> left <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="serialize-and-deserialize-binary-tree" tabindex="-1"><a class="header-anchor" href="#serialize-and-deserialize-binary-tree" aria-hidden="true">#</a> Serialize and Deserialize Binary Tree</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener noreferrer">how LeetCode serializes a binary tree<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!----></span></a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="zxczxc"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = []
Output: []
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1]
Output: [1]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2]
Output: [1,2]
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Solution</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
class Codec <span class="token punctuation">{</span>
public<span class="token operator">:</span>

       string <span class="token function">serialize</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">&quot;#&quot;</span><span class="token punctuation">;</span> 
        string serial <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
        serial <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span><span class="token operator">+</span> <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> serial<span class="token punctuation">;</span>          
    <span class="token punctuation">}</span>
    TreeNode<span class="token operator">*</span> <span class="token function">helper</span><span class="token punctuation">(</span>string data<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">&#39;#&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>i<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        string r <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> 
        <span class="token keyword">while</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">&#39;,&#39;</span><span class="token punctuation">)</span>r<span class="token operator">+=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">;</span> 
        i<span class="token operator">++</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">!=</span><span class="token string">&quot;#&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
            TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token keyword">return</span> root<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    
    TreeNode<span class="token operator">*</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>string data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Your Codec object will be instantiated and called as such:</span>
<span class="token comment">// Codec ser, deser;</span>
<span class="token comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="balanced-binary-tree" tabindex="-1"><a class="header-anchor" href="#balanced-binary-tree" aria-hidden="true">#</a> Balanced Binary Tree</h2><blockquote><p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="asd"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [3,9,20,null,null,15,7]
Output: true
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="askld"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: root = []
Output: true
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="solution" tabindex="-1"><a class="header-anchor" href="#solution" aria-hidden="true">#</a> <strong>Solution</strong></h3><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    bool <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bool flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
        <span class="token function">isOne</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">isOne</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span>bool<span class="token operator">&amp;</span> flag<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token function">isOne</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r<span class="token operator">=</span><span class="token function">isOne</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>l<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span> flag<span class="token operator">=</span>false<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="convert-sorted-array-to-binary-search-tree" tabindex="-1"><a class="header-anchor" href="#convert-sorted-array-to-binary-search-tree" aria-hidden="true">#</a> Convert Sorted Array to Binary Search Tree</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="asda"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="aslkd"></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="zlxkc"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Input: nums = [1,3]
Output: [3,1]
Explanation: [1,3] and [3,1] are both a height-balanced BSTs.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="solution-1" tabindex="-1"><a class="header-anchor" href="#solution-1" aria-hidden="true">#</a> <strong>Solution</strong></h3><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
class Solution <span class="token punctuation">{</span>
public<span class="token operator">:</span>
    TreeNode<span class="token operator">*</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">solution</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    TreeNode<span class="token operator">*</span> <span class="token function">solution</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&gt;</span>r<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        TreeNode<span class="token operator">*</span> t <span class="token operator">=</span> new <span class="token function">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>left<span class="token operator">=</span><span class="token function">solution</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>right<span class="token operator">=</span><span class="token function">solution</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link meta-item-label" href="https://github.com/vuepress-reco/vuepress-theme-reco-next/edit/main/example//blogs/C++/Tree.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Edit this page<!--]--></span></a><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!----></span><!--[--><!--]--></a></div><!----></footer><!----><!----></main><!--]--><div class="page-header-container"><h5 class="tip">ON THIS PAGE</h5><ul><!--[--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Tree<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#binary-tree-preorder-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Binary Tree Preorder Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Binary Tree Preorder Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#binary-tree-inorder-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Binary Tree Inorder Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Binary Tree Inorder Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#binary-tree-postorder-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Binary Tree Postorder Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Binary Tree Postorder Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#binary-tree-level-order-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Binary Tree Level Order Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Binary Tree Level Order Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#find-max-depth" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Find Max Depth"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Find Max Depth<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#conclusion" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Conclusion"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Conclusion<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#symmetric-tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Symmetric Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Symmetric Tree<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#path-sum" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Path Sum"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Path Sum<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#construct-binary-tree-from-inorder-and-postorder-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Construct Binary Tree from Inorder and Postorder Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Construct Binary Tree from Inorder and Postorder Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#construct-binary-tree-from-preorder-and-inorder-traversal" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Construct Binary Tree from Preorder and Inorder Traversal"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Construct Binary Tree from Preorder and Inorder Traversal<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#populating-next-right-pointers-in-each-node" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Populating Next Right Pointers in Each Node"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Populating Next Right Pointers in Each Node<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#lowest-common-ancestor-of-a-binary-tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Lowest Common Ancestor of a Binary Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Lowest Common Ancestor of a Binary Tree<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#serialize-and-deserialize-binary-tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Serialize and Deserialize Binary Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Serialize and Deserialize Binary Tree<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#balanced-binary-tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Balanced Binary Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Balanced Binary Tree<!--]--></span></a><!--[--><!--]--></a></li><!--[--><li class="page-header-menu-depth_3"><a aria-current="page" href="/blogs/C++/Tree.html#solution" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Solution"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Solution<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--]--><!--[--><li class="page-header-menu-depth_2"><a aria-current="page" href="/blogs/C++/Tree.html#convert-sorted-array-to-binary-search-tree" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Convert Sorted Array to Binary Search Tree"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Convert Sorted Array to Binary Search Tree<!--]--></span></a><!--[--><!--]--></a></li><!--[--><li class="page-header-menu-depth_3"><a aria-current="page" href="/blogs/C++/Tree.html#solution-1" class="router-link-active router-link-exact-active nav-link page-header-item" aria-label="Solution"><!--[--><!--]--><a class="icon-container left" href="javascript:void(0)"><!----><span style="color:inherit;font-size:14px;"><!--[-->Solution<!--]--></span></a><!--[--><!--]--></a></li><!--]--><!--]--><!--]--></ul></div></div></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.6ffafc36.js" defer></script><script src="/assets/js/3769.cb625991.js" defer></script><script src="/assets/js/app.f55d247c.js" defer></script>
  </body>
</html>
