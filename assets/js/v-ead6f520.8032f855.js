"use strict";(self.webpackChunkvuepress_theme_reco_demo=self.webpackChunkvuepress_theme_reco_demo||[]).push([[9014],{9443:(e,s,a)=>{a.r(s),a.d(s,{data:()=>n});const n={key:"v-ead6f520",path:"/blogs/React/Hooks.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Hooks",slug:"hooks",children:[{level:3,title:"是什么",slug:"是什么",children:[]},{level:3,title:"为什么需要？",slug:"为什么需要",children:[]},{level:3,title:"使用规则",slug:"使用规则",children:[]},{level:3,title:"对Hook调用与组件联系起来",slug:"对hook调用与组件联系起来",children:[]},{level:3,title:"useState",slug:"usestate",children:[]},{level:3,title:"useEffect",slug:"useeffect",children:[]},{level:3,title:"useCallback",slug:"usecallback",children:[]}]}],git:{},filePathRelative:"blogs/React/Hooks.md"}},5546:(e,s,a)=>{a.r(s),a.d(s,{default:()=>l});const n=(0,a(6252).uE)('<h2 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> Hooks</h2><p><strong><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</strong></p><h3 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么" aria-hidden="true">#</a> 是什么</h3><p><strong>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。</strong></p><h3 id="为什么需要" tabindex="-1"><a class="header-anchor" href="#为什么需要" aria-hidden="true">#</a> 为什么需要？</h3><ul><li>在组件之间复用状态逻辑很难</li><li>复杂组件变得难以理解</li><li>难以理解的class</li></ul><h3 id="使用规则" tabindex="-1"><a class="header-anchor" href="#使用规则" aria-hidden="true">#</a> 使用规则</h3><ul><li>只能在<strong>函数最外层</strong>调用 Hook。<strong>不要在循环、条件判断或者子函数中调用</strong>。</li><li>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）</li></ul><h3 id="对hook调用与组件联系起来" tabindex="-1"><a class="header-anchor" href="#对hook调用与组件联系起来" aria-hidden="true">#</a> 对Hook调用与组件联系起来</h3><p>每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 <code>useState()</code> 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 <code>useState()</code> 调用会得到各自独立的本地 state 的原因。</p><h3 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate" aria-hidden="true">#</a> useState</h3><p>过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。</p><p><code>useState</code> 会返回一对值：<strong>当前</strong>状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。</p><h3 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect" aria-hidden="true">#</a> useEffect</h3><p><strong>给函数组件增加副作用能力.</strong></p><p><strong>调用时, 流程是React对DOM完成更改(每次渲染)后运行副作用函数, 通过返回一个函数来清除副作用(组件销毁时).</strong></p><div class="language-react ext-react line-numbers-mode"><pre class="language-react"><code>useEffect(() =&gt; {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () =&gt; {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>使用Hook目的: 解决class中生命周期函数经常包含不相关的逻辑,但又把相关逻辑分离到了几个不同方法的问题.</strong></p><p><strong>性能优化:通过跳过Effect进行性能优化<code>useEffect(()=&gt;{},[state])</code>, 仅在state变化时更新</strong></p><h3 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback" aria-hidden="true">#</a> useCallback</h3><p>把你要的函数用 useCallback 包一层, 定义好只有什么参数变化时, 这个被包过的函数才需要更新</p><div class="language-tsx ext-tsx line-numbers-mode"><pre class="language-tsx"><code><span class="token keyword">const</span> yourfunc <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>\n\t<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n\t<span class="token comment">// 你要写的函数逻辑</span>\n\t\n\t<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n\t\t<span class="token comment">// 在数组里定义什么参数改变时才需要更新 yourfunc,</span>\n\t\t<span class="token comment">// 只要这里的依赖的参数没有变对于任何使用它的一方它都没有变</span>\n\t<span class="token punctuation">]</span>\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div>',22),t={},l=(0,a(3744).Z)(t,[["render",function(e,s){return n}]])}}]);