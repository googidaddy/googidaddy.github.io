(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{505:function(s,a,e){"use strict";e.r(a);var t=e(4),n=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"c-基础学习-三"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-基础学习-三"}},[s._v("#")]),s._v(" C++基础学习（三）")]),s._v(" "),e("h2",{attrs:{id:"数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[s._v("#")]),s._v(" 数组")]),s._v(" "),e("p",[e("strong",[s._v("数组是存放相同类型对象的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的大小是固定的，不能随意改变数组的长度。")])]),s._v(" "),e("h3",{attrs:{id:"定义数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义数组"}},[s._v("#")]),s._v(" 定义数组")]),s._v(" "),e("p",[e("strong",[s._v("数组的声明形如 "),e("code",[s._v("a[d]")]),s._v("，其中，"),e("code",[s._v("a")]),s._v(" 是数组的名字，"),e("code",[s._v("d")]),s._v(" 是数组中元素的个数。在编译时，"),e("code",[s._v("d")]),s._v(" 应该是已知的，也就是说，"),e("code",[s._v("d")]),s._v(" 应该是一个整型的常量表达式。")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("unsigned int d1 = 42;\nconst int d2 = 42;\nint arr1[d1];  // 错误：d1 不是常量表达式\nint arr2[d2];  // 正确：arr2 是一个长度为 42 的数组\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 不能将一个数组直接赋值给另一个数组\nint arr1[3];\nint arr2 = arr1;  // 错误\narr2 = arr1;      // 错误\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("blockquote",[e("p",[s._v("应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("#include <iostream>\nusing namespace std;\n\nint arr[1001];  // 数组 arr 的下标范围是 [0, 1001)\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> arr[i];\n  }\n}\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("h3",{attrs:{id:"多维数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多维数组"}},[s._v("#")]),s._v(" 多维数组")]),s._v(" "),e("p",[e("strong",[s._v("多维数组的实质是「数组的数组」，即外层数组的元素是数组。一个二维数组需要两个维度来定义：数组的长度和数组内元素的长度。访问二维数组时需要写出两个索引：")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("int arr[3][4];  // 一个长度为 3 的数组，它的元素是「元素为 int 的长度为的 4\n                // 的数组」\narr[2][1] = 1;  // 访问二维数组\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[e("strong",[s._v("例：从标准输入中读取两个数 n和 m，分别表示黑白图片的高与宽，满足n，m<=1000 。对于接下来的 n行数据，每行有用空格分隔开的 m个数，代表这一位置的亮度值。现在我们读取这张图片，并将其存入二维数组中。")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const int maxn = 1001;\nint pic[maxn][maxn];\nint n, m;\n\ncin >> n >> m;\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= n; ++j) cin >> pic[i][j];\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h2",{attrs:{id:"结构体"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[s._v("#")]),s._v(" 结构体")]),s._v(" "),e("h3",{attrs:{id:"定义结构体"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义结构体"}},[s._v("#")]),s._v(" 定义结构体")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("struct Object {\n  int weight;\n  int value;\n} e[array_length];\n\nconst Object a;\nObject b, B[array_length], tmp;\nObject *c;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("上例中定义了一个名为 "),e("code",[s._v("Object")]),s._v(" 的结构体，两个成员元素 "),e("code",[s._v("value, weight")]),s._v("，类型都为 "),e("code",[s._v("int")]),s._v("。")]),s._v(" "),e("p",[s._v("在 "),e("code",[s._v("}")]),s._v(" 后，定义了数据类型为 "),e("code",[s._v("Object")]),s._v(" 的常量 "),e("code",[s._v("a")]),s._v("，变量 "),e("code",[s._v("b")]),s._v("，变量 "),e("code",[s._v("tmp")]),s._v("，数组 "),e("code",[s._v("B")]),s._v("，指针 "),e("code",[s._v("c")]),s._v("。对于某种已经存在的类型，都可以使用这里的方法进行定义常量、变量、指针、数组等。")]),s._v(" "),e("p",[e("em",[e("strong",[s._v("关于指针：不必强求掌握。")])])]),s._v(" "),e("h3",{attrs:{id:"文件的操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件的操作"}},[s._v("#")]),s._v(" 文件的操作")]),s._v(" "),e("p",[s._v("1、打开文件，将文件指针指向文件，决定打开文件类型；\n2、对文件进行读、写操作（比赛中主要用到的操作，其他一些操作暂时不写）；\n3、在使用完文件后，关闭文件。")]),s._v(" "),e("h4",{attrs:{id:"freopen"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#freopen"}},[s._v("#")]),s._v(" freopen")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("FILE* freopen(const char* filename, const char* mode, FILE* stream);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h5",{attrs:{id:"参数说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数说明"}},[s._v("#")]),s._v(" 参数说明")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("filename")]),s._v(": 要打开的文件名")]),s._v(" "),e("li",[e("code",[s._v("mode")]),s._v(": 文件打开的模式，表示文件访问的权限")]),s._v(" "),e("li",[e("code",[s._v("stream")]),s._v(": 文件指针，通常使用标准文件流 ("),e("code",[s._v("stdin/stdout")]),s._v(") 或标准错误输出流 ("),e("code",[s._v("stderr")]),s._v(")")]),s._v(" "),e("li",[s._v("返回值：文件指针，指向被打开文件")])]),s._v(" "),e("h5",{attrs:{id:"文件打开格式-选读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件打开格式-选读"}},[s._v("#")]),s._v(" 文件打开格式（选读）")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("r")]),s._v("：以只读方式打开文件，文件必须存在，只允许读入数据 "),e("strong",[s._v("（常用）")])]),s._v(" "),e("li",[e("code",[s._v("r+")]),s._v("：以读/写方式打开文件，文件必须存在，允许读写数据")]),s._v(" "),e("li",[e("code",[s._v("rb")]),s._v("：以只读方式打开二进制文件，文件必须存在，只允许读入数据")]),s._v(" "),e("li",[e("code",[s._v("rb+")]),s._v("：以读写方式打开二进制文件，文件必须存在，允许读写数据")]),s._v(" "),e("li",[e("code",[s._v("rt+")]),s._v("：以读写方式打开文本文件，允许读写")]),s._v(" "),e("li",[e("code",[s._v("w")]),s._v("：以只写方式打开文件，文件不存在会新建文件，否则清空内容，只允许写入数据 "),e("strong",[s._v("（常用）")])]),s._v(" "),e("li",[e("code",[s._v("w+")]),s._v("：以读/写方式打开文件，文件不存在将新建文件，否则清空内容，允许读写数据")]),s._v(" "),e("li",[e("code",[s._v("wb")]),s._v("：以只读方式打开二进制文件，文件不存在将会新建文件，否则清空内容，只允许写入数据")]),s._v(" "),e("li",[e("code",[s._v("wb+")]),s._v("：以读写方式打开二进制文件，文件不存在将新建文件，否则清空内容，允许读写数据")]),s._v(" "),e("li",[e("code",[s._v("a")]),s._v("：以附加方式打开只写文件，文件不存在将新建文件，写入数据将被附加在文件末尾（保留 EOF 符）")]),s._v(" "),e("li",[e("code",[s._v("a+")]),s._v("：以附加方式打开只写文件，文件不存在将新建文件，写入数据将被附加在文件末尾（不保留 EOF 符）")]),s._v(" "),e("li",[e("code",[s._v("at+")]),s._v("：以读写方式打开文本文件，写入数据将被附加在文件末尾")]),s._v(" "),e("li",[e("code",[s._v("ab+")]),s._v("：以读写方式打开二进制文件，写入数据将被附加在文件末尾")])]),s._v(" "),e("h4",{attrs:{id:"使用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[s._v("#")]),s._v(" 使用方法")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('freopen("data.in", "r", stdin);\n// data.in 就是读取的文件名，要和可执行文件放在同一目录下\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('freopen("data.out", "w", stdout);\n// data.out 就是输出文件的文件名，和可执行文件在同一目录下\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("fclose(stdin);\nfclose(stdout);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("blockquote",[e("p",[e("code",[s._v("printf/scanf/cin/cout")]),s._v(" 等函数默认使用 "),e("code",[s._v("stdin/stdout")]),s._v("，将 "),e("code",[s._v("stdin/stdout")]),s._v(" 重定向后，这些函数将输入/输出到被定向的文件")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('#include <cstdio>\n#include <iostream>\nint main(void) {\n  freopen("data.in", "r", stdin);\n  freopen("data.out", "w", stdout);\n  /*\n  中间的代码不需要改变，直接使用 cin 和 cout 即可\n  */\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("h3",{attrs:{id:"fopen"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fopen"}},[s._v("#")]),s._v(" fopen")]),s._v(" "),e("p",[e("strong",[s._v("函数大致与 "),e("code",[s._v("freopen")]),s._v(" 相同，函数将打开指定文件并返回打开文件的指针")])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("FILE* fopen(const char* path, const char* mode)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h4",{attrs:{id:"可用读写函数-基本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可用读写函数-基本"}},[s._v("#")]),s._v(" 可用读写函数（基本）")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("fread/fwrite")])]),s._v(" "),e("li",[e("code",[s._v("fgetc/fputc")])]),s._v(" "),e("li",[e("code",[s._v("fscanf/fprintf")])]),s._v(" "),e("li",[e("code",[s._v("fgets/fputs")])])]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('FILE *in, *out;  // 定义文件指针\nin = fopen("data.in", "r");\nout = fopen("data.out", "w");\n/*\ndo what you want to do\n*/\nfclose(stdin);\nfclose(stdout);\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("h3",{attrs:{id:"ifstream-ofstream-文件输入输出流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ifstream-ofstream-文件输入输出流"}},[s._v("#")]),s._v(" "),e("code",[s._v("ifstream/ofstream")]),s._v(" 文件输入输出流")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('ifstream fin("data.in");\n// data.in 就是读取文件的相对位置或绝对位置\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('ofstream fout("data.out");\n// data.out 就是输出文件的相对位置或绝对位置\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("fin.close();\nfout.close();\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('#include <cstdio>\n#include <fstream>\nifstream fin("data.in");\nofstream fout("data.out");\nint main(void) {\n  /*\n  中间的代码改变 cin 为 fin ，cout 为 fout 即可\n  */\n  fin.close();\n  fout.close();\n  return 0;\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("h2",{attrs:{id:"c-标准库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-标准库"}},[s._v("#")]),s._v(" C++标准库")]),s._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5Cdomado%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210314161533078.png",alt:"image-20210314161533078"}})]),s._v(" "),e("h3",{attrs:{id:"序列式容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#序列式容器"}},[s._v("#")]),s._v(" 序列式容器")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("向量")]),s._v("("),e("code",[s._v("vector")]),s._v(") 后端可高效增加元素的顺序表。")]),s._v(" "),e("li",[e("strong",[s._v("数组")]),s._v("("),e("code",[s._v("array")]),s._v(")"),e("strong",[s._v("C++11")]),s._v("，定长的顺序表，C 风格数组的简单包装。")]),s._v(" "),e("li",[e("strong",[s._v("双端队列")]),s._v("("),e("code",[s._v("deque")]),s._v(") 双端都可高效增加元素的顺序表。")]),s._v(" "),e("li",[e("strong",[s._v("列表")]),s._v("("),e("code",[s._v("list")]),s._v(") 可以沿双向遍历的链表。")]),s._v(" "),e("li",[e("strong",[s._v("单向列表")]),s._v("("),e("code",[s._v("forward_list")]),s._v(") 只能沿一个方向遍历的链表。")])]),s._v(" "),e("h3",{attrs:{id:"关联式容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关联式容器"}},[s._v("#")]),s._v(" 关联式容器")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("集合")]),s._v("("),e("code",[s._v("set")]),s._v(") 用以有序地存储 "),e("strong",[s._v("互异")]),s._v(" 元素的容器。其实现是由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种比较元素大小的谓词进行排列。")]),s._v(" "),e("li",[e("strong",[s._v("多重集合")]),s._v("("),e("code",[s._v("multiset")]),s._v(") 用以有序地存储元素的容器。允许存在相等的元素。")]),s._v(" "),e("li",[e("strong",[s._v("映射")]),s._v("("),e("code",[s._v("map")]),s._v(") 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。")]),s._v(" "),e("li",[e("strong",[s._v("多重映射")]),s._v("("),e("code",[s._v("multimap")]),s._v(") 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。")])]),s._v(" "),e("h3",{attrs:{id:"迭代器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[s._v("#")]),s._v(" 迭代器")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("vector<int> data(10);\n\nfor (int i = 0; i < data.size(); i++)\n  cout << data[i] << endl;  // 使用下标访问元素\n\nfor (vector<int>::iterator iter = data.begin(); iter != data.end(); iter++)\n  cout << *iter << endl;  // 使用迭代器访问元素\n// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("h3",{attrs:{id:"序列式容器-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#序列式容器-2"}},[s._v("#")]),s._v(" 序列式容器")]),s._v(" "),e("h4",{attrs:{id:"vector"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vector"}},[s._v("#")]),s._v(" vector")]),s._v(" "),e("p",[e("code",[s._v("std::vector")]),s._v(" 是 STL 提供的 "),e("strong",[s._v("内存连续的")]),s._v("、"),e("strong",[s._v("可变长度")]),s._v(" 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。")]),s._v(" "),e("h5",{attrs:{id:"vector-可以动态分配内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vector-可以动态分配内存"}},[s._v("#")]),s._v(" "),e("code",[s._v("vector")]),s._v(" 可以动态分配内存")]),s._v(" "),e("p",[s._v("很多时候我们不能提前开好那么大的空间（eg：预处理 1~n 中所有数的约数）。尽管我们能知道数据总量在空间允许的级别，但是单份数据还可能非常大，这种时候我们就需要 "),e("code",[s._v("vector")]),s._v(" 来把内存占用量控制在合适的范围内。"),e("code",[s._v("vector")]),s._v(" 还支持动态扩容，在内存非常紧张的时候这个特性就能派上用场了。")]),s._v(" "),e("h5",{attrs:{id:"vector-重写了比较运算符及赋值运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vector-重写了比较运算符及赋值运算符"}},[s._v("#")]),s._v(" "),e("code",[s._v("vector")]),s._v(" 重写了比较运算符及赋值运算符")]),s._v(" "),e("p",[e("code",[s._v("vector")]),s._v(" 重载了六个比较运算符，以字典序实现，这使得我们可以方便的判断两个容器是否相等（复杂度与容器大小成线性关系）。例如可以利用 "),e("code",[s._v("vector<char>")]),s._v(" 实现字符串比较（当然，还是用 "),e("code",[s._v("std::string")]),s._v(" 会更快更方便）。另外 "),e("code",[s._v("vector")]),s._v(" 也重载了赋值运算符，使得数组拷贝更加方便。")]),s._v(" "),e("h5",{attrs:{id:"vector-便利的初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vector-便利的初始化"}},[s._v("#")]),s._v(" "),e("code",[s._v("vector")]),s._v(" 便利的初始化")]),s._v(" "),e("p",[s._v("于 "),e("code",[s._v("vector")]),s._v(" 重载了 "),e("code",[s._v("=")]),s._v(" 运算符，所以我们可以方便的初始化。"),e("code",[s._v("vector<int> data {1, 2, 3};")]),s._v("。")]),s._v(" "),e("h5",{attrs:{id:"构造"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造"}},[s._v("#")]),s._v(" 构造")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 1. 创建空vector; 常数复杂度\nvector<int> v0;\n// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度\nv0.reserve(3);\n// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度\nvector<int> v1(3);\n// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度\nvector<int> v2(3, 2);\n// 4. 创建一个初始空间为3的vector，其元素的默认值是1，\n// 并且使用v2的空间配置器; 线性复杂度\nvector<int> v3(3, 1, v2.get_allocator());\n// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度\nvector<int> v4(v2);\n// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度\nvector<int> v5(v4.begin() + 1, v4.begin() + 3);\n// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11\nvector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br")])]),e("h5",{attrs:{id:"访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问"}},[s._v("#")]),s._v(" 访问")]),s._v(" "),e("p",[e("code",[s._v("vector")]),s._v(" 提供了如下几种方法进行元素访问")]),s._v(" "),e("ol",[e("li",[e("p",[e("code",[s._v("at()")])]),s._v(" "),e("p",[e("code",[s._v("v.at(pos)")]),s._v(" 返回容器中下标为 "),e("code",[s._v("pos")]),s._v(" 的引用。如果数组越界抛出 "),e("code",[s._v("std::out_of_range")]),s._v(" 类型的异常。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("operator[]")])]),s._v(" "),e("p",[e("code",[s._v("v[pos]")]),s._v(" 返回容器中下标为 "),e("code",[s._v("pos")]),s._v(" 的引用。不执行越界检查。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("front()")])]),s._v(" "),e("p",[e("code",[s._v("v.front()")]),s._v(" 返回首元素的引用。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("back()")])]),s._v(" "),e("p",[e("code",[s._v("v.back()")]),s._v(" 返回末尾元素的引用。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("data()")])]),s._v(" "),e("p",[e("code",[s._v("v.data()")]),s._v(" 返回指向数组第一个元素的指针。")])])]),s._v(" "),e("h5",{attrs:{id:"迭代器-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#迭代器-2"}},[s._v("#")]),s._v(" 迭代器")]),s._v(" "),e("ol",[e("li",[e("p",[e("code",[s._v("begin()/cbegin()")])]),s._v(" "),e("p",[s._v("返回指向首元素的迭代器，其中 "),e("code",[s._v("*begin = front")]),s._v("。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("end()/cend()")])]),s._v(" "),e("p",[s._v("返回指向数组尾端占位符的迭代器，注意是没有元素的。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("rbegin()/rcbegin()")])]),s._v(" "),e("p",[s._v("返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("rend()/rcend()")])]),s._v(" "),e("p",[s._v("返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。")])])]),s._v(" "),e("h5",{attrs:{id:"长度和容量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长度和容量"}},[s._v("#")]),s._v(" 长度和容量")]),s._v(" "),e("ul",[e("li",[e("p",[e("code",[s._v("empty()")]),s._v(" 返回一个 "),e("code",[s._v("bool")]),s._v(" 值，即 "),e("code",[s._v("v.begin() == v.end()")]),s._v("，"),e("code",[s._v("true")]),s._v(" 为空，"),e("code",[s._v("false")]),s._v(" 为非空。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("size()")]),s._v(" 返回容器长度（元素数量），即 "),e("code",[s._v("std::distance(v.begin(), v.end())")]),s._v("。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("resize()")]),s._v(" 改变 "),e("code",[s._v("vector")]),s._v(" 的长度，多退少补。补充元素可以由参数指定。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("max_size()")]),s._v(" 返回容器的最大可能长度。")]),s._v(" "),e("p",[e("strong",[s._v("与容量相关")]),s._v("：")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("reserve()")]),s._v(" 使得 "),e("code",[s._v("vector")]),s._v(" 预留一定的内存空间，避免不必要的内存拷贝。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("capacity()")]),s._v(" 返回容器的容量，即不发生拷贝的情况下容器的长度上限。")])]),s._v(" "),e("li",[e("p",[e("code",[s._v("shrink_to_fit()")]),s._v(" 使得 "),e("code",[s._v("vector")]),s._v(" 的容量与长度一致，多退但不会少。")])])]),s._v(" "),e("h5",{attrs:{id:"元素增删改"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素增删改"}},[s._v("#")]),s._v(" 元素增删改")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("clear()")]),s._v(" 清除所有元素")]),s._v(" "),e("li",[e("code",[s._v("insert()")]),s._v(" 支持在某个迭代器位置插入元素、可以插入多个。"),e("strong",[s._v("复杂度与 "),e("code",[s._v("pos")]),s._v(" 距离末尾长度成线性而非常数的")])]),s._v(" "),e("li",[e("code",[s._v("erase()")]),s._v(" 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 "),e("code",[s._v("insert")]),s._v(" 一致。")]),s._v(" "),e("li",[e("code",[s._v("push_back()")]),s._v(" 在末尾插入一个元素，均摊复杂度为 "),e("strong",[s._v("常数")]),s._v("，最坏为线性复杂度。")]),s._v(" "),e("li",[e("code",[s._v("pop_back()")]),s._v(" 删除末尾元素，常数复杂度。")]),s._v(" "),e("li",[e("code",[s._v("swap()")]),s._v(" 与另一个容器进行交换，此操作是 "),e("strong",[s._v("常数复杂度")]),s._v(" 而非线性的。")])]),s._v(" "),e("h3",{attrs:{id:"array"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array"}},[s._v("#")]),s._v(" array")]),s._v(" "),e("h4",{attrs:{id:"元素访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素访问"}},[s._v("#")]),s._v(" 元素访问")]),s._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5Cdomado%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210314163712010.png",alt:"image-20210314163712010"}})]),s._v(" "),e("blockquote",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("at` 若遇 `pos >= size()` 的情况会抛出 `std::out_of_range\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])])]),s._v(" "),e("h4",{attrs:{id:"容量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容量"}},[s._v("#")]),s._v(" 容量")]),s._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5Cdomado%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210314163758183.png",alt:"image-20210314163758183"}})]),s._v(" "),e("p",[s._v("由于每个 "),e("code",[s._v("array")]),s._v(" 都是固定大小容器，"),e("code",[s._v("size()")]),s._v(" 返回的值等于 "),e("code",[s._v("max_size()")]),s._v(" 返回的值。")]),s._v(" "),e("h4",{attrs:{id:"操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[s._v("#")]),s._v(" 操作")]),s._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5Cdomado%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210314163816852.png",alt:"image-20210314163816852"}})]),s._v(" "),e("h4",{attrs:{id:"实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[s._v("#")]),s._v(" 实例")]),s._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('// 1. 创建空array，长度为3; 常数复杂度\nstd::array<int, 3> v0;\n// 2. 用指定常数创建array; 常数复杂度\nstd::array<int, 3> v1{1, 2, 3};\n\nv0.fill(1);  // 填充数组\n\n// 访问数组\nfor (int i = 0; i != arr.size(); ++i) cout << arr[i] << " ";\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("h3",{attrs:{id:"deque"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#deque"}},[s._v("#")]),s._v(" deque")]),s._v(" "),e("p",[e("code",[s._v("std::deque")]),s._v(" 是 STL 提供的 双端队列数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问")]),s._v(" "),e("p",[s._v("以下介绍常用用法，详细内容 "),e("a",{attrs:{href:"https://zh.cppreference.com/w/cpp/container/deque",target:"_blank",rel:"noopener noreferrer"}},[s._v("请参见 C++ 文档"),e("OutboundLink")],1),s._v("。"),e("code",[s._v("deque")]),s._v(" 的迭代器函数与 "),e("code",[s._v("vector")]),s._v(" 相同，因此不作详细介绍。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 1. 定义一个int类型的空双端队列 v0\ndeque<int> v0;\n// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度\ndeque<int> v1(10);\n// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度\ndeque<int> v2(10, 1);\n// 4. 复制已有的双端队列 v1; 线性复杂度\ndeque<int> v3(v1);\n// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度\ndeque<int> v4(v2.begin(), v2.begin() + 3);\n// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11\ndeque<int> v5(std::move(v2));\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("h4",{attrs:{id:"访问-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问-2"}},[s._v("#")]),s._v(" 访问")]),s._v(" "),e("p",[s._v("与 "),e("code",[s._v("vector")]),s._v(" 一致，但无法访问底层内存。其高效的元素访问速度可参考实现细节部分。")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("at()")]),s._v(" 返回容器中指定位置元素的引用，执行越界检查，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("operator[]")]),s._v(" 返回容器中指定位置元素的引用。不执行越界检查，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("front()")]),s._v(" 返回首元素的引用。")]),s._v(" "),e("li",[e("code",[s._v("back()")]),s._v(" 返回末尾元素的引用。")])]),s._v(" "),e("h4",{attrs:{id:"长度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长度"}},[s._v("#")]),s._v(" 长度")]),s._v(" "),e("p",[s._v("与 "),e("code",[s._v("vector")]),s._v(" 一致，但是没有 "),e("code",[s._v("reserve()")]),s._v(" 和 "),e("code",[s._v("capacity()")]),s._v(" 函数。（仍然有 "),e("code",[s._v("shrink_to_fit()")]),s._v(" 函数）")]),s._v(" "),e("h4",{attrs:{id:"元素增删改-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素增删改-2"}},[s._v("#")]),s._v(" 元素增删改")]),s._v(" "),e("p",[s._v("与 "),e("code",[s._v("vector")]),s._v(" 一致，并额外有向队列头部增加元素的函数。")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("clear()")]),s._v(" 清除所有元素")]),s._v(" "),e("li",[e("code",[s._v("insert()")]),s._v(" 支持在某个迭代器位置插入元素、可以插入多个。"),e("strong",[s._v("复杂度与 "),e("code",[s._v("pos")]),s._v(" 与两端距离较小者成线性")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("erase()")]),s._v(" 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 "),e("code",[s._v("insert")]),s._v(" 一致。")]),s._v(" "),e("li",[e("code",[s._v("push_front()")]),s._v(" 在头部插入一个元素，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("pop_front()")]),s._v(" 删除头部元素，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("push_back()")]),s._v(" 在末尾插入一个元素，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("pop_back()")]),s._v(" 删除末尾元素，"),e("strong",[s._v("常数复杂度")]),s._v("。")]),s._v(" "),e("li",[e("code",[s._v("swap()")]),s._v(" 与另一个容器进行交换，此操作是 "),e("strong",[s._v("常数复杂度")]),s._v(" 而非线性的。")])]),s._v(" "),e("h3",{attrs:{id:"list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" list")]),s._v(" "),e("p",[e("code",[s._v("std::list")]),s._v(" 是 STL 提供的 双向链表数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。")]),s._v(" "),e("p",[e("code",[s._v("ist")]),s._v(" 的使用方法与 "),e("code",[s._v("deque")]),s._v(" 基本相同，但是增删操作和访问的复杂度不同。详细内容 "),e("a",{attrs:{href:"https://zh.cppreference.com/w/cpp/container/list",target:"_blank",rel:"noopener noreferrer"}},[s._v("请参见 C++ 文档"),e("OutboundLink")],1),s._v("。"),e("code",[s._v("list")]),s._v(" 的迭代器、长度、元素增删及修改相关的函数与 "),e("code",[s._v("deque")]),s._v(" 相同，因此不作详细介绍。")])])}),[],!1,null,null,null);a.default=n.exports}}]);