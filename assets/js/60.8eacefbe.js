(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{546:function(t,s,a){"use strict";a.r(s);var e=a(4),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" Hooks")]),t._v(" "),a("p",[a("strong",[a("em",[t._v("Hook")]),t._v(" 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")])]),t._v(" "),a("h3",{attrs:{id:"是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[t._v("#")]),t._v(" 是什么")]),t._v(" "),a("p",[a("strong",[t._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。")])]),t._v(" "),a("h3",{attrs:{id:"为什么需要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要"}},[t._v("#")]),t._v(" 为什么需要？")]),t._v(" "),a("ul",[a("li",[t._v("在组件之间复用状态逻辑很难")]),t._v(" "),a("li",[t._v("复杂组件变得难以理解")]),t._v(" "),a("li",[t._v("难以理解的class")])]),t._v(" "),a("h3",{attrs:{id:"使用规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用规则"}},[t._v("#")]),t._v(" 使用规则")]),t._v(" "),a("ul",[a("li",[t._v("只能在"),a("strong",[t._v("函数最外层")]),t._v("调用 Hook。"),a("strong",[t._v("不要在循环、条件判断或者子函数中调用")]),t._v("。")]),t._v(" "),a("li",[t._v("只能在 "),a("strong",[t._v("React 的函数组件")]),t._v("中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）")])]),t._v(" "),a("h3",{attrs:{id:"对hook调用与组件联系起来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对hook调用与组件联系起来"}},[t._v("#")]),t._v(" 对Hook调用与组件联系起来")]),t._v(" "),a("p",[t._v("每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 "),a("code",[t._v("useState()")]),t._v(" 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 "),a("code",[t._v("useState()")]),t._v(" 调用会得到各自独立的本地 state 的原因。")]),t._v(" "),a("h3",{attrs:{id:"usestate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[t._v("#")]),t._v(" useState")]),t._v(" "),a("p",[t._v("过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。")]),t._v(" "),a("p",[a("code",[t._v("useState")]),t._v(" 会返回一对值："),a("strong",[t._v("当前")]),t._v("状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。")]),t._v(" "),a("h3",{attrs:{id:"useeffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[t._v("#")]),t._v(" useEffect")]),t._v(" "),a("p",[a("strong",[t._v("给函数组件增加副作用能力.")])]),t._v(" "),a("p",[a("strong",[t._v("调用时, 流程是React对DOM完成更改(每次渲染)后运行副作用函数, 通过返回一个函数来清除副作用(组件销毁时).")])]),t._v(" "),a("div",{staticClass:"language-react line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[a("strong",[t._v("使用Hook目的: 解决class中生命周期函数经常包含不相关的逻辑,但又把相关逻辑分离到了几个不同方法的问题.")])]),t._v(" "),a("p",[a("strong",[t._v("性能优化:通过跳过Effect进行性能优化"),a("code",[t._v("useEffect(()=>{},[state])")]),t._v(", 仅在state变化时更新")])]),t._v(" "),a("h3",{attrs:{id:"usecallback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),a("p",[t._v("把你要的函数用 useCallback 包一层, 定义好只有什么参数变化时, 这个被包过的函数才需要更新")]),t._v(" "),a("div",{staticClass:"language-tsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-tsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" yourfunc "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 你要写的函数逻辑")]),t._v("\n\t\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在数组里定义什么参数改变时才需要更新 yourfunc,")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只要这里的依赖的参数没有变对于任何使用它的一方它都没有变")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);