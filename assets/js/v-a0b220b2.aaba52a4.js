"use strict";(self.webpackChunkvuepress_theme_reco_demo=self.webpackChunkvuepress_theme_reco_demo||[]).push([[2698],{9861:(e,r,n)=>{n.r(r),n.d(r,{data:()=>a});const a={key:"v-a0b220b2",path:"/blogs/React/React16%E6%96%B0%E6%9E%B6%E6%9E%84.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"React16新架构",slug:"react16新架构",children:[{level:3,title:"源码的结构",slug:"源码的结构",children:[]}]}],git:{},filePathRelative:"blogs/React/React16新架构.md"}},7390:(e,r,n)=>{n.r(r),n.d(r,{default:()=>g});var a=n(6252);const s=(0,a._)("h2",{id:"react16新架构",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#react16新架构","aria-hidden":"true"},"#"),(0,a.Uk)(" React16新架构")],-1),t={href:"https://react.iamkasong.com",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("source"),l=(0,a.uE)('<ul><li><p><strong>从递归更新变成可中断更新</strong></p></li><li><p><strong>多了Scheduler（Reconciler、Renderer）</strong></p></li></ul><p><strong>工作原理变化：首先由Scheduler调度器调度任务的优先级，高优先任务先进入Reconciler,Reconciler标记所有需要更新的虚拟DOM（标记在内存中操作，并且Reconciler不再与Renderer交替工作），之后交由Renderer渲染</strong></p><p><img src="C:\\Users\\domado\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210618220350630.png" alt="image-20210618220350630"></p><p>其中红框中的步骤随时可能由于以下原因被中断：</p><ul><li>有其他更高优任务需要先更新</li><li>当前帧没有剩余时间</li></ul><p>由于红框中的工作都在内存中进行，不会更新页面上的DOM，所以即使反复中断，用户也不会看见更新不完全的DOM（即上一节演示的情况）。</p><ul><li><code>Reconciler</code>工作的阶段被称为<code>render</code>阶段。因为在该阶段会调用组件的<code>render</code>方法。</li><li><code>Renderer</code>工作的阶段被称为<code>commit</code>阶段。就像你完成一个需求的编码后执行<code>git commit</code>提交代码。<code>commit</code>阶段会把<code>render</code>阶段提交的信息渲染在页面上。</li><li><code>render</code>与<code>commit</code>阶段统称为<code>work</code>，即<code>React</code>在工作中。相对应的，如果任务正在<code>Scheduler</code>内调度，就不属于<code>work</code>。</li></ul><p><img src="https://user-images.githubusercontent.com/31481964/85862700-b41e2880-b7f4-11ea-9f28-b9e0a39e1498.png" alt="image"></p>',8),i=(0,a._)("u",null,[(0,a._)("strong",null,"在render阶段")],-1),p=(0,a.Uk)("，React将更新应用于通过setState或render方法触发的组件，并确定需要在用户屏幕上做哪些更新--哪些节点需要插入，更新或删除，哪些组件需要调用其生命周期方法。最终的这些更新信息被保存在一个叫effect list的fiber 节点树上（关于fiber的内容，在这篇文章中有简述"),o={href:"https://github.com/mbaxszy7/blog/issues/14",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("react中的fiber"),b=(0,a.Uk)("）。当然，在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。"),u=(0,a.uE)('<p>在上图中， render阶段被标记为纯的、没有副作用的，可能会被React暂停、终止或者重新执行。也就是说，React会根据产生的任务的优先级，安排任务的调度（schedule）。利用类似requestIdleCallback的原理在浏览器空闲阶段进行更新计算，而不会阻塞动画，事件等的执行。</p><hr><p><u><strong>在commit阶段</strong></u></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>current fiber tree: 在首次渲染时，React不需要产生任何更新信息，而是会给每个从render方法返回的element生成一个fiber节点，最终生成一个fiber节点树， 后续的更新也是复用了这棵fiber树。\n\nworkInProgress fiber tree: \n所有的更新计算工作都在workInProgress tree的fiber上执行。当React 遍历current fiber tree时，它为每个current fiber 创建一个替代（alternate）节点，这样的alternate节点构成了workInProgress tree\n\neffect list fiber tree: workInProgress fiber tree 的子树，这个树的作用串联了标记具有更新的节点\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>commit阶段会遍历effect list，把所有更新都commit到DOM树上。具体的，首先会有一个pre-commit阶段，主要是执行getSnapshotBeforeUpdate方法，可以获取当前DOM的快照（snap）。然后给需要卸载的组件执行componentWillUnmount方法。接着会把current fiber tree 替换为workInProgress fiber tree。最后执行DOM的插入、更新和删除，给更新的组件执行componentDidUpdate，给插入的组件执行componentDidMount。</p><p><u><strong>重点要注意的是，这一阶段是同步执行的，不能中止</strong></u>。</p><hr><h3 id="源码的结构" tabindex="-1"><a class="header-anchor" href="#源码的结构" aria-hidden="true">#</a> 源码的结构</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>根目录\n├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目\n├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）\n├── scripts         # 各种工具链的脚本，比如git、jest、eslint等\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="packages" tabindex="-1"><a class="header-anchor" href="#packages" aria-hidden="true">#</a> packages</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>├── react \t\t\t# react的核心，包含全局的API\n├── shceduler\t\t# Scheduler的实现\n├── shared\t\t\t# 源码中其他模块公用的方法和全局变量\n├── renderer\n├─────react-art\n├─────react-dom  \t# 注意这是同时DOM和SSR(服务端渲染)的入口\n├─────react-native-renderer\n├─────react-noop-renderer\t# 用于debug fiber\n├─────react-test-renderer\n├── test\t\t\t# 抽出出来独立的包，实验性质所以不建议生产环境使用\n├─────react-server \t\t# 创建自定义SSR流\n├─────react-client \t\t# 创建自定义流\n├─────react-fetch\t\t# 用于数据请求\n├─────react-interactions # 用于测试交互相关的内部特性，such as:React的事件模型\n├─────react-reconciler\t# Reconciler的实现，构建自己的Renderer\n├── 辅助包\t\t\t  # 辅助功能单独形成的包\n├─────react-is \t\t# 用于测试组件是否是某类型\n├─────react-client  # 创建自定义流\n├─────react-fetch   # 用于数据请求\n├─────react-refresh # “热重载”的官方版本\n├── react-reconciler\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div>',11),m={},g=(0,n(3744).Z)(m,[["render",function(e,r){const n=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)(a.HY,null,[s,(0,a._)("p",null,[(0,a._)("a",t,[c,(0,a.Wm)(n)])]),l,(0,a._)("p",null,[i,p,(0,a._)("a",o,[d,(0,a.Wm)(n)]),b]),u],64)}]])}}]);